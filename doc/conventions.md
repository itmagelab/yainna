# Соглашения по разработке

> Правила кодирования для проекта финансового помощника.
> Основано на [техническом видении](vision.md).

## Обязательные правила

### Безопасность кода

- **ЗАПРЕЩЕНО** использовать `unwrap()` и `expect()` (lint: `#![deny(clippy::unwrap_used)]`)
- **ОБЯЗАТЕЛЬНО** обрабатывать ошибки через Result<T>
- **ОБЯЗАТЕЛЬНО** использовать `?` оператор для пробрасывания ошибок
- **ОБЯЗАТЕЛЬНО** логировать ошибки с контекстом через `tracing`

### Архитектурные ограничения

- **ЗАПРЕЩЕНО** хардкод конфигурации - только переменные окружения
- **ОБЯЗАТЕЛЬНО** использовать CQRS паттерн (Command/Query разделение)
- **ОБЯЗАТЕЛЬНО** проходить `ctx` через все слои приложения
- **ОБЯЗАТЕЛЬНО** следовать существующей архитектуре проекта без отклонений
- **ЗАПРЕЩЕНО** вводить новые архитектурные паттерны без согласования

### Типобезопасность

- **ОБЯЗАТЕЛЬНО** использовать доменные типы (`TransactionType`, а не строки)
- **ЗАПРЕЩЕНО** использовать `i32`/`u32` для ID без обертки
- **ОБЯЗАТЕЛЬНО** валидация данных на границах модулей
- **ЗАПРЕЩЕНО** `Any` типы и dynamic dispatch без веских причин

## Именование

### Файлы и модули

- snake_case для файлов и модулей
- Один основной тип на файл
- **ЗАПРЕЩЕНО** использование `mod.rs` во всем проекте
- **ЗАПРЕЩЕНО** использование `index.html` для создания стилей, и компонентов
- Для создания компонентов разрешается использовать только `Yew`
- **ОБЯЗАТЕЛЬНО** использовать именованные модули для организации кода в папки:
  - Создать папку с нужным именем (например, `utils/`, `handlers/`, `services/`)
  - Создать файл с именем папки в корне `src/` для объявления подмодулей (например, `utils.rs`, `handlers.rs`, `services.rs`)
  - В этом файле объявить публичные подмодули:

    ```rust
    // Файл src/utils.rs
    pub mod api;
    pub mod telegram;
    pub mod ui;
    ```

  - В `main.rs` или `lib.rs` добавить `mod utils;`
  - Каждый файл в папке является отдельным подмодулем
  - Импорты: `use crate::utils::api;`, `use crate::handlers::user;`
  - Этот подход обеспечивает явное управление модулями и избегает неявного поведения `mod.rs`

### Переменные и функции

- snake_case для функций и переменных
- Глаголы для функций (`create_transaction`, не `transaction_create`)
- Существительные для переменных (`user_id`, не `get_user_id`)

## Обработка ошибок

### Типы ошибок

- **ОБЯЗАТЕЛЬНО** использовать `anyhow!` и `bail!` макросы для всех ошибок
- **ЗАПРЕЩЕНО** добавлять новые варианты в `error::Error` enum
- **РАЗРЕШЕНО** использовать `error::Error` только для явной обработки специфических ошибок
- **ОБЯЗАТЕЛЬНО** контекст для каждой ошибки через `anyhow!` или `.context()`

### Примеры обработки ошибок

```rust
// ✅ Правильно - использование anyhow! макроса
if currency_code.len() != 3 {
    return Err(anyhow!("Currency code must be exactly 3 characters, got: {}", currency_code));
}

// ✅ Правильно - использование bail! макроса
if amount.is_zero() {
    bail!("Transaction amount cannot be zero");
}

// ✅ Правильно - добавление контекста
let user = get_user(id)
    .context("Failed to retrieve user for transaction")?;

// ❌ Неправильно - добавление новых вариантов в Error enum
// return Err(Error::NewCustomError.into());

// ✅ Правильно - использование существующих ошибок только для обработки
match result {
    Err(e) if e.downcast_ref::<Error>() == Some(&Error::UserNotFound) => {
        // специфическая обработка
    }
    Err(e) => return Err(e),
}
```

### Логирование

- `tracing::error!` для критических ошибок
- `tracing::warn!` для неожиданных ситуаций
- `tracing::info!` для важных операций
- `tracing::debug!` для детальной диагностики

## Асинхронный код

### Async/await

- **ОБЯЗАТЕЛЬНО** все I/O операции асинхронные
- **ЗАПРЕЩЕНО** блокирующие вызовы в async функциях
- **ОБЯЗАТЕЛЬНО** `Send + Sync` для типов в async контексте

## Тестирование

### Unit тесты

- **ОБЯЗАТЕЛЬНО** тесты для всей бизнес-логики
- **ОБЯЗАТЕЛЬНО** mock'и для внешних зависимостей
- **ЗАПРЕЩЕНО** тесты, зависящие от внешних сервисов

### Интеграционные тесты

- **ОБЯЗАТЕЛЬНО** тесты для критических user flow
- **ОБЯЗАТЕЛЬНО** использовать тестовую БД
- **ОБЯЗАТЕЛЬНО** cleanup после каждого теста

## Конфигурация

### Переменные окружения

- **ЗАПРЕЩЕНО** дефолтные значения для секретных данных
- **ОБЯЗАТЕЛЬНО** проверка обязательных переменных при старте
- **ОБЯЗАТЕЛЬНО** понятные сообщения об ошибках конфигурации
- **ОБЯЗАТЕЛЬНО** обновление `env.example` при добавлении новых переменных

## Производительность

### Базы данных

- **ОБЯЗАТЕЛЬНО** индексы на часто запрашиваемые поля
- **ЗАПРЕЩЕНО** N+1 запросы
- **ОБЯЗАТЕЛЬНО** пагинация для больших выборок
- **ОБЯЗАТЕЛЬНО** LIMIT в SQL запросах

### Память

- **ЗАПРЕЩЕНО** загрузка больших объемов в память без стриминга
- **ОБЯЗАТЕЛЬНО** использование `Iterator` вместо `Vec` где возможно
- **ЗАПРЕЩЕНО** клонирование тяжелых структур без необходимости

## Документация

### Код

- **ОБЯЗАТЕЛЬНО** документация для всех публичных API
- **ОБЯЗАТЕЛЬНО** примеры использования в doc-комментариях
- **ЗАПРЕЩЕНО** комментарии, дублирующие код

### ADR

- **ОБЯЗАТЕЛЬНО** ADR для всех архитектурных решений
- **ОБЯЗАТЕЛЬНО** обновление статуса при изменении решений

## Безопасность

### Данные

- **ЗАПРЕЩЕНО** логирование чувствительных данных (токены, пароли)
- **ОБЯЗАТЕЛЬНО** валидация всех пользовательских данных
- **ОБЯЗАТЕЛЬНО** использование UUID для внешних идентификаторов

### API

- **ЗАПРЕЩЕНО** прямая передача внутренних ошибок пользователю
- **ОБЯЗАТЕЛЬНО** rate limiting для внешних API
- **ОБЯЗАТЕЛЬНО** проверка прав доступа на каждый запрос

### Генерация кода

- **Создание новых сущностей:** следовать паттерну существующих модулей
- **Добавление команд/запросов:** использовать CQRS паттерн
- **Обновление шаблонов:** изменять файлы в `templates/`
- **Не быть многословным:** Не расписывать подробно каждый шаг или задачу, только спрашивать о нужных действиях.
