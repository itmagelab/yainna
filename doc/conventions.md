# Соглашения по разработке

> Правила кодирования для проекта финансового помощника.
> Основано на [техническом видении](vision.md).

## Технологический стек

### Frontend

- **CSS фреймворк**: Tailwind CSS (через CDN)
- **Иконки**: Font Awesome
- **Компоненты**: Только через Yew (запрещено использовать `index.html` для стилей и компонентов)
- **Данные контента**: YAML файлы в директории `static/`

## Обязательные правила

### Безопасность кода

- **ЗАПРЕЩЕНО** использовать `unwrap()` и `expect()` (lint: `#![deny(clippy::unwrap_used)]`)
- **ОБЯЗАТЕЛЬНО** обрабатывать ошибки через Result<T>
- **ОБЯЗАТЕЛЬНО** использовать `?` оператор для пробрасывания ошибок
- **ОБЯЗАТЕЛЬНО** логировать ошибки с контекстом через `tracing`

### Архитектурные ограничения

- **ЗАПРЕЩЕНО** хардкод конфигурации - только переменные окружения
- **ОБЯЗАТЕЛЬНО** использовать CQRS паттерн (Command/Query разделение)
- **ОБЯЗАТЕЛЬНО** проходить `ctx` через все слои приложения
- **ОБЯЗАТЕЛЬНО** следовать существующей архитектуре проекта без отклонений
- **ЗАПРЕЩЕНО** вводить новые архитектурные паттерны без согласования

### Типобезопасность

- **ОБЯЗАТЕЛЬНО** использовать доменные типы (`TransactionType`, а не строки)
- **ЗАПРЕЩЕНО** использовать `i32`/`u32` для ID без обертки
- **ОБЯЗАТЕЛЬНО** валидация данных на границах модулей
- **ЗАПРЕЩЕНО** `Any` типы и dynamic dispatch без веских причин
- **ОБЯЗАТЕЛЬНО** использовать `serde` для десериализации данных из YAML

## Структура данных

### YAML файлы

- **ОБЯЗАТЕЛЬНО** хранить контент сайта в `static/content.yaml`
- **ОБЯЗАТЕЛЬНО** создавать Rust структуры с `#[derive(Deserialize)]` для каждой секции
- **ОБЯЗАТЕЛЬНО** использовать `snake_case` для полей в YAML
- **ОБЯЗАТЕЛЬНО** обрабатывать ошибки загрузки через `Result<T, String>`
- **ЗАПРЕЩЕНО** использовать `unwrap()` при парсинге YAML

## Именование

### Файлы и модули

- snake_case для файлов и модулей
- Один основной тип на файл
- **ЗАПРЕЩЕНО** использование `mod.rs` во всем проекте
- **ЗАПРЕЩЕНО** использование `index.html` для создания стилей и компонентов
- Для создания компонентов разрешается использовать только `Yew`
- **ОБЯЗАТЕЛЬНО** использовать Tailwind CSS для стилизации компонентов
- **ОБЯЗАТЕЛЬНО** использовать именованные модули для организации кода в папки:
  - Создать папку с нужным именем (например, `utils/`, `handlers/`, `services/`)
  - Создать файл с именем папки в корне `src/` для объявления подмодулей (например, `utils.rs`, `handlers.rs`, `services.rs`)
  - В этом файле объявить публичные подмодули:

    ```rust
    // Файл src/utils.rs
    pub mod api;
    pub mod telegram;
    pub mod ui;
    ```

  - В `main.rs` или `lib.rs` добавить `mod utils;`
  - Каждый файл в папке является отдельным подмодулем
  - Импорты: `use crate::utils::api;`, `use crate::handlers::user;`
  - Этот подход обеспечивает явное управление модулями и избегает неявного поведения `mod.rs`

### Переменные и функции

- snake_case для функций и переменных
- Глаголы для функций (`create_transaction`, не `transaction_create`)
- Существительные для переменных (`user_id`, не `get_user_id`)

## Обработка ошибок

### Типы ошибок

- **ОБЯЗАТЕЛЬНО** использовать `anyhow!` и `bail!` макросы для всех ошибок
- **ЗАПРЕЩЕНО** добавлять новые варианты в `error::Error` enum
- **РАЗРЕШЕНО** использовать `error::Error` только для явной обработки специфических ошибок
- **ОБЯЗАТЕЛЬНО** контекст для каждой ошибки через `anyhow!` или `.context()`

### Примеры обработки ошибок

```rust
// ✅ Правильно - использование anyhow! макроса
if currency_code.len() != 3 {
    return Err(anyhow!("Currency code must be exactly 3 characters, got: {}", currency_code));
}

// ✅ Правильно - использование bail! макроса
if amount.is_zero() {
    bail!("Transaction amount cannot be zero");
}

// ✅ Правильно - добавление контекста
let user = get_user(id)
    .context("Failed to retrieve user for transaction")?;

// ❌ Неправильно - добавление новых вариантов в Error enum
// return Err(Error::NewCustomError.into());

// ✅ Правильно - использование существующих ошибок только для обработки
match result {
    Err(e) if e.downcast_ref::<Error>() == Some(&Error::UserNotFound) => {
        // специфическая обработка
    }
    Err(e) => return Err(e),
}
```

### Логирование

- `tracing::error!` для критических ошибок
- `tracing::warn!` для неожиданных ситуаций
- `tracing::info!` для важных операций
- `tracing::debug!` для детальной диагностики

## Асинхронный код

### Async/await

- **ОБЯЗАТЕЛЬНО** все I/O операции асинхронные
- **ЗАПРЕЩЕНО** блокирующие вызовы в async функциях
- **ОБЯЗАТЕЛЬНО** `Send + Sync` для типов в async контексте

## Тестирование

### Unit тесты

- **ОБЯЗАТЕЛЬНО** тесты для всей бизнес-логики
- **ОБЯЗАТЕЛЬНО** mock'и для внешних зависимостей
- **ЗАПРЕЩЕНО** тесты, зависящие от внешних сервисов

### Интеграционные тесты

- **ОБЯЗАТЕЛЬНО** тесты для критических user flow
- **ОБЯЗАТЕЛЬНО** использовать тестовую БД
- **ОБЯЗАТЕЛЬНО** cleanup после каждого теста

## Конфигурация

### Переменные окружения

- **ЗАПРЕЩЕНО** дефолтные значения для секретных данных
- **ОБЯЗАТЕЛЬНО** проверка обязательных переменных при старте
- **ОБЯЗАТЕЛЬНО** понятные сообщения об ошибках конфигурации
- **ОБЯЗАТЕЛЬНО** обновление `env.example` при добавлении новых переменных

## Производительность

### Базы данных

- **ОБЯЗАТЕЛЬНО** индексы на часто запрашиваемые поля
- **ЗАПРЕЩЕНО** N+1 запросы
- **ОБЯЗАТЕЛЬНО** пагинация для больших выборок
- **ОБЯЗАТЕЛЬНО** LIMIT в SQL запросах

### Память

- **ЗАПРЕЩЕНО** загрузка больших объемов в память без стриминга
- **ОБЯЗАТЕЛЬНО** использование `Iterator` вместо `Vec` где возможно
- **ЗАПРЕЩЕНО** клонирование тяжелых структур без необходимости

## Документация

### Код

- **ОБЯЗАТЕЛЬНО** документация для всех публичных API
- **ОБЯЗАТЕЛЬНО** примеры использования в doc-комментариях
- **ЗАПРЕЩЕНО** комментарии, дублирующие код

### ADR

- **ОБЯЗАТЕЛЬНО** ADR для всех архитектурных решений
- **ОБЯЗАТЕЛЬНО** обновление статуса при изменении решений

## Безопасность

### Данные

- **ЗАПРЕЩЕНО** логирование чувствительных данных (токены, пароли)
- **ОБЯЗАТЕЛЬНО** валидация всех пользовательских данных
- **ОБЯЗАТЕЛЬНО** использование UUID для внешних идентификаторов

### API

- **ЗАПРЕЩЕНО** прямая передача внутренних ошибок пользователю
- **ОБЯЗАТЕЛЬНО** rate limiting для внешних API
- **ОБЯЗАТЕЛЬНО** проверка прав доступа на каждый запрос

## Git

### Commit сообщения

- **ОБЯЗАТЕЛЬНО** использовать только английский язык для commit сообщений
- **ОБЯЗАТЕЛЬНО** следовать формату: `<type>: <description>`
- **Типы коммитов:**
  - `feat:` - новая функциональность
  - `fix:` - исправление ошибки
  - `docs:` - изменения в документации
  - `style:` - форматирование кода (без изменения логики)
  - `refactor:` - рефакторинг кода
  - `test:` - добавление или изменение тестов
  - `chore:` - изменения в конфигурации, сборке и т.д.
- **ЗАПРЕЩЕНО** использовать русский язык в commit сообщениях
- **ОБЯЗАТЕЛЬНО** краткое описание (до 72 символов)

**Примеры:**
```
feat: add user authentication module
fix: resolve transaction calculation error
docs: update API documentation
refactor: simplify error handling in handlers
```

### Работа с Git

- **ЗАПРЕЩЕНО** выполнять `git commit` без явного разрешения пользователя
- **ОБЯЗАТЕЛЬНО** спрашивать разрешение перед каждым коммитом
- **ОБЯЗАТЕЛЬНО** показывать изменения (`git status`, `git diff`) перед коммитом
- **РАЗРЕШЕНО** использовать `git add` для подготовки файлов
- **ЗАПРЕЩЕНО** делать `git push` без явного указания пользователя

### Генерация кода

- **Создание новых сущностей:** следовать паттерну существующих модулей
- **Добавление команд/запросов:** использовать CQRS паттерн
- **Обновление шаблонов:** изменять файлы в `templates/`
- **Не быть многословным:** Не расписывать подробно каждый шаг или задачу, только спрашивать о нужных действиях.

### Работа с контентом

- **Разделение данных и представления:** весь контент хранится в YAML, компоненты только отображают
- **Загрузка данных:** использовать `gloo-net` для HTTP запросов
- **Асинхронность:** загружать данные в `use_effect_with` с `spawn_local`
- **Состояние загрузки:** показывать индикатор загрузки до получения данных
